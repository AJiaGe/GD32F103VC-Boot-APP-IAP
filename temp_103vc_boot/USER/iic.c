#include "iic.h"
#include "gd32f10x.h"
#include "systick.h"
#include "usart0.h"
#include <stdio.h>

/*********************************************************************************************************
* 函 数 名 : I2C_GPIO_Init
* 功能说明 : I2C GPIO初始化
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : 无
*********************************************************************************************************/ 

void I2C_GPIO_Init( void )
{
	/* enable GPIOB clock */
    rcu_periph_clock_enable(RCU_GPIOB);

    /* PB6 to I2C0_SCL */
    /* PB7 to I2C0_SDA */
    gpio_init(GPIOB, GPIO_MODE_AF_OD, GPIO_OSPEED_50MHZ, GPIO_PIN_6 | GPIO_PIN_7);
	
	I2C_SCL = 1;
	I2C_SDA = 1;
}


/*********************************************************************************************************
* 函 数 名 : I2C_Config_Init
* 功能说明 : I2C配置
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : 无
*********************************************************************************************************/ 

void I2C_Config_Init( void )
{
	/* enable I2C clock */
    rcu_periph_clock_enable(RCU_I2C0);
	
    /* configure I2C clock */
    i2c_clock_config(I2C0, I2C0_SPEED, I2C_DTCY_2);
	
    /* configure I2C address */
    i2c_mode_addr_config(I2C0, I2C_I2CMODE_ENABLE, I2C_ADDFORMAT_7BITS, I2C0_SLAVE_ADDRESS7);
	
    /* enable I2C0 */
    i2c_enable(I2C0);
	
    /* enable acknowledge */
    i2c_ack_config(I2C0, I2C_ACK_ENABLE);
}


/*********************************************************************************************************
* 函 数 名 : I2C_Init
* 功能说明 : I2C初始化
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : 无
*********************************************************************************************************/ 

void I2C_Init( void )
{
	I2C_GPIO_Init();
//	I2C_Config_Init();
}

/*********************************************************************************************************
* 函 数 名 : IIC_Start
* 功能说明 : 产生IIC起止信号
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : SCL为高电平期间，SDA由高电平向低电平的跳变。
*********************************************************************************************************/

void I2C_Start(void)
{
    I2C_SCL = 1;	//总线空闲为高
    I2C_SDA = 1;
    Delay_Us(5);	//保持，为了产生下沿的动作
    I2C_SDA = 0;	//SCL为高电平期间，SDA由高电平向低电平的跳变
    Delay_Us(5);
}


/*********************************************************************************************************
* 函 数 名 : IIC_Stop
* 功能说明 : 产生IIC结束信号
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : SCL为高电平期间，SDA由低电平向高电平的跳变。
*********************************************************************************************************/

void I2C_Stop(void)
{
    I2C_SCL = 0;
    I2C_SDA = 0;	//拉低SDA，为产生上沿做准备
    Delay_Us(5);
    I2C_SCL = 1;	//SCL为高电平期间
    Delay_Us(5);
    I2C_SDA = 1;	//SDA由低电平向高电平的跳变
}


/*********************************************************************************************************
* 函 数 名 : IIC_ACK_NACK
* 功能说明 : 作为接收方时，每个字节（8bit）传输完成后的下一个时钟信号，发起应答或非应答信号
* 形    参 : ack：0应答，1非应答
* 返 回 值 :
* 备    注 : 在SCL为高电平期间，SDA为低，则表示一个应答信号（ACK）；SDA为高，则表示一个非应答信号（NACK）。
*********************************************************************************************************/

void I2C_ACK_NACK(uint8_t ack)
{
    I2C_SCL = 0;

    if(ack) 			//根据形参决定产生应答或者非应答信号
    {
        I2C_SDA = 1;
    }
    else
    {
        I2C_SDA = 0;
    }

    Delay_Us(5);
    I2C_SCL = 1;
    Delay_Us(5);
    I2C_SCL = 0;
}


/*********************************************************************************************************
* 函 数 名 : IIC_Wait_ACK
* 功能说明 : 作为发送方时，检测从机返回的应答信号
* 形    参 : 无
* 返 回 值 : 0：应答，1：非应答
* 备    注 :
*********************************************************************************************************/

uint8_t I2C_Wait_ACK(void)
{
    uint8_t error = 0;

    I2C_SDA = 1;	//释放数据线，否则对方无法操作
    I2C_SCL = 1;
    Delay_Us(5);

    while(I2C_SDAIN) 	//SDA被拉低则认为是一个非应答信号
    {
        if(++error > 250)
        {
            return 1;
        }
    }

    return 0;	//认为对方发起了一个应答信号
}


/*********************************************************************************************************
* 函 数 名 : IIC_WriteByte
* 功能说明 : 发送一个字节的数据到IIC总线上
* 形    参 : data：需要发送的数据
* 返 回 值 : 无
* 备    注 : MSB（高位在前）
*********************************************************************************************************/

void I2C_Write_Byte(uint8_t data)
{
    uint8_t i;

    for(i = 0; i < 8; i++)
    {
        I2C_SCL = 0;				//低电平才能改变数据线的状态
        I2C_SDA = !!(data & 0x80);	//把一位数据放到数据线上
        data <<= 1;					//更新最高位
        Delay_Us(5);
        I2C_SCL = 1;				//数据已经准备好了，通知从机读取
        Delay_Us(5);
    }

    I2C_SCL = 0;
    Delay_Us(5);
}


/*********************************************************************************************************
* 函 数 名 : IIC_ReadByte
* 功能说明 : 读取IIC总线上的一个字节
* 形    参 : ack：0应答，1非应答
* 返 回 值 : 读取到的数据
* 备    注 : MSB（高位在前）
*********************************************************************************************************/

uint8_t I2C_Read_Byte(uint8_t ack)
{
    uint8_t i, data;

    I2C_SDA = 1;			//释放数据线，对方才能操作

    for(i = 0; i < 8; i++)
    {
        I2C_SCL = 0;		//通知对方准备数据
        Delay_Us(5);
        I2C_SCL = 1;		//主机要读数据了，从机不允许再修改
        data <<= 1;			//先空出最低位
        data |= I2C_SDAIN;	//读取数据线上的一位数据
        Delay_Us(5);
    }

    I2C_ACK_NACK(ack);

    return data;
}

